"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransaction = exports.CreateTransactionError = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("./constants");
/**
 * Thrown when a valid transaction can't be created from the inputs provided.
 */
class CreateTransactionError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'CreateTransactionError';
    }
}
exports.CreateTransactionError = CreateTransactionError;
/**
 * Create a Solana Pay transaction.
 *
 * **Reference** implementation for wallet providers.
 *
 * @param connection - A connection to the cluster.
 * @param payer - `PublicKey` of the payer.
 * @param recipient - `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient)
 * @param amount - `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount)
 * @param {CreateTransactionParams} createTransactionParams - Additional parameters
 * @param createTransactionParams.splToken
 * @param createTransactionParams.reference
 * @param createTransactionParams.memo
 */
function createTransaction(connection, payer, recipient, amount, { splToken, reference, memo } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check that the payer and recipient accounts exist
        const payerInfo = yield connection.getAccountInfo(payer);
        if (!payerInfo)
            throw new CreateTransactionError('payer not found');
        const recipientInfo = yield connection.getAccountInfo(recipient);
        if (!recipientInfo)
            throw new CreateTransactionError('recipient not found');
        // A native SOL or SPL token transfer instruction
        let instruction;
        // If no SPL token mint is provided, transfer native SOL
        if (!splToken) {
            // Check that the payer and recipient are valid native accounts
            if (!payerInfo.owner.equals(web3_js_1.SystemProgram.programId))
                throw new CreateTransactionError('payer owner invalid');
            if (payerInfo.executable)
                throw new CreateTransactionError('payer executable');
            if (!recipientInfo.owner.equals(web3_js_1.SystemProgram.programId))
                throw new CreateTransactionError('recipient owner invalid');
            if (recipientInfo.executable)
                throw new CreateTransactionError('recipient executable');
            // Check that the amount provided doesn't have greater precision than SOL
            if (amount.decimalPlaces() > constants_1.SOL_DECIMALS)
                throw new CreateTransactionError('amount decimals invalid');
            // Convert input decimal amount to integer lamports
            amount = amount.times(web3_js_1.LAMPORTS_PER_SOL).integerValue(bignumber_js_1.default.ROUND_FLOOR);
            // Check that the payer has enough lamports
            const lamports = amount.toNumber();
            if (lamports > payerInfo.lamports)
                throw new CreateTransactionError('insufficient funds');
            // Create an instruction to transfer native SOL
            instruction = web3_js_1.SystemProgram.transfer({
                fromPubkey: payer,
                toPubkey: recipient,
                lamports,
            });
        }
        // Otherwise, transfer SPL tokens from payer's ATA to recipient's ATA
        else {
            // Check that the token provided is an initialized mint
            const mint = yield (0, spl_token_1.getMint)(connection, splToken);
            if (!mint.isInitialized)
                throw new CreateTransactionError('mint not initialized');
            // Check that the amount provided doesn't have greater precision than the mint
            if (amount.decimalPlaces() > mint.decimals)
                throw new CreateTransactionError('amount decimals invalid');
            // Convert input decimal amount to integer tokens according to the mint decimals
            amount = amount.times(constants_1.TEN.pow(mint.decimals)).integerValue(bignumber_js_1.default.ROUND_FLOOR);
            // Get the payer's ATA and check that the account exists and can send tokens
            const payerATA = yield (0, spl_token_1.getAssociatedTokenAddress)(splToken, payer);
            const payerAccount = yield (0, spl_token_1.getAccount)(connection, payerATA);
            if (!payerAccount.isInitialized)
                throw new CreateTransactionError('payer not initialized');
            if (payerAccount.isFrozen)
                throw new CreateTransactionError('payer frozen');
            // Get the recipient's ATA and check that the account exists and can receive tokens
            const recipientATA = yield (0, spl_token_1.getAssociatedTokenAddress)(splToken, recipient);
            const recipientAccount = yield (0, spl_token_1.getAccount)(connection, recipientATA);
            if (!recipientAccount.isInitialized)
                throw new CreateTransactionError('recipient not initialized');
            if (recipientAccount.isFrozen)
                throw new CreateTransactionError('recipient frozen');
            // Check that the payer has enough tokens
            const tokens = BigInt(String(amount));
            if (tokens > payerAccount.amount)
                throw new CreateTransactionError('insufficient funds');
            // Create an instruction to transfer SPL tokens, asserting the mint and decimals match
            instruction = (0, spl_token_1.createTransferCheckedInstruction)(payerATA, splToken, recipientATA, payer, tokens, mint.decimals);
        }
        // If reference accounts are provided, add them to the transfer instruction
        if (reference) {
            if (!Array.isArray(reference)) {
                reference = [reference];
            }
            for (const pubkey of reference) {
                instruction.keys.push({ pubkey, isWritable: false, isSigner: false });
            }
        }
        // Create the transaction
        const transaction = new web3_js_1.Transaction();
        // If a memo is provided, add it to the transaction before adding the transfer instruction
        if (memo != null) {
            transaction.add(new web3_js_1.TransactionInstruction({
                programId: constants_1.MEMO_PROGRAM_ID,
                keys: [],
                data: Buffer.from(memo, 'utf8'),
            }));
        }
        // Add the transfer instruction to the transaction
        transaction.add(instruction);
        return transaction;
    });
}
exports.createTransaction = createTransaction;
//# sourceMappingURL=createTransaction.js.map